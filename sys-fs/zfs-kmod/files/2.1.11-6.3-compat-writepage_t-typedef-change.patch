From 87b91626330696dc57d3f1de6d6659b1b71fed1b Mon Sep 17 00:00:00 2001
From: Spotlight <spotlight@joscomputing.space>
Date: Wed, 26 Apr 2023 13:04:16 -0500
Subject: [PATCH 1/2] Backport "Linux 6.3 compat: writepage_t first arg struct
 folio*"

---
 config/kernel-writepage_t.m4   | 26 ++++++++++++++++++++++++++
 config/kernel.m4               |  2 ++
 module/os/linux/zfs/zpl_file.c | 17 +++++++++++++++++
 3 files changed, 45 insertions(+)
 create mode 100644 config/kernel-writepage_t.m4

diff --git a/config/kernel-writepage_t.m4 b/config/kernel-writepage_t.m4
new file mode 100644
index 00000000000..3a0cffd9857
--- /dev/null
+++ b/config/kernel-writepage_t.m4
@@ -0,0 +1,26 @@
+AC_DEFUN([ZFS_AC_KERNEL_SRC_WRITEPAGE_T], [
+	dnl #
+	dnl # 6.3 API change
+	dnl # The writepage_t function type now has its first argument as
+	dnl # struct folio* instead of struct page*
+	dnl #
+	ZFS_LINUX_TEST_SRC([writepage_t_folio], [
+		#include <linux/writeback.h>
+		int putpage(struct folio *folio,
+		    struct writeback_control *wbc, void *data)
+		{ return 0; }
+		writepage_t func = putpage;
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_WRITEPAGE_T], [
+	AC_MSG_CHECKING([whether int (*writepage_t)() takes struct folio*])
+	ZFS_LINUX_TEST_RESULT([writepage_t_folio], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_WRITEPAGE_T_FOLIO, 1,
+		   [int (*writepage_t)() takes struct folio*])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
diff --git a/config/kernel.m4 b/config/kernel.m4
index b376a151694..b64cca7a1f9 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -148,6 +148,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
 	ZFS_AC_KERNEL_SRC___COPY_FROM_USER_INATOMIC
 	ZFS_AC_KERNEL_SRC_IDMAP_MNT_API
 	ZFS_AC_KERNEL_SRC_IATTR_VFSID
+	ZFS_AC_KERNEL_SRC_WRITEPAGE_T
 
 	AC_MSG_CHECKING([for available kernel interfaces])
 	ZFS_LINUX_TEST_COMPILE_ALL([kabi])
@@ -269,6 +270,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
 	ZFS_AC_KERNEL___COPY_FROM_USER_INATOMIC
 	ZFS_AC_KERNEL_IDMAP_MNT_API
 	ZFS_AC_KERNEL_IATTR_VFSID
+	ZFS_AC_KERNEL_WRITEPAGE_T
 ])
 
 dnl #
diff --git a/module/os/linux/zfs/zpl_file.c b/module/os/linux/zfs/zpl_file.c
index f124599393f..2bdb53579ae 100644
--- a/module/os/linux/zfs/zpl_file.c
+++ b/module/os/linux/zfs/zpl_file.c
@@ -701,6 +701,15 @@ zpl_putpage(struct page *pp, struct writeback_control *wbc, void *data)
 	return (0);
 }
 
+#ifdef HAVE_WRITEPAGE_T_FOLIO
+static int
+zpl_putfolio(struct folio *pp, struct writeback_control *wbc, void *data)
+{
+	(void) zpl_putpage(&pp->page, wbc, data);
+	return (0);
+}
+#endif
+
 static int
 zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
@@ -723,7 +732,11 @@ zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 	 * and then we commit it all in one go.
 	 */
 	wbc->sync_mode = WB_SYNC_NONE;
+#ifdef HAVE_WRITEPAGE_T_FOLIO
+	result = write_cache_pages(mapping, wbc, zpl_putfolio, mapping);
+#else
 	result = write_cache_pages(mapping, wbc, zpl_putpage, mapping);
+#endif
 	if (sync_mode != wbc->sync_mode) {
 		ZPL_ENTER(zfsvfs);
 		ZPL_VERIFY_ZP(zp);
@@ -739,7 +752,11 @@ zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 		 * details). That being said, this is a no-op in most cases.
 		 */
 		wbc->sync_mode = sync_mode;
+#ifdef HAVE_WRITEPAGE_T_FOLIO
+		result = write_cache_pages(mapping, wbc, zpl_putfolio, mapping);
+#else
 		result = write_cache_pages(mapping, wbc, zpl_putpage, mapping);
+#endif
 	}
 	return (result);
 }

From 04e8c37ff2490d1933fcb7f5c42da3e11b50bf7c Mon Sep 17 00:00:00 2001
From: Spotlight <spotlight@joscomputing.space>
Date: Wed, 26 Apr 2023 13:11:02 -0500
Subject: [PATCH 2/2] Backport "Add zpl_write_cache_pages()"

---
 module/os/linux/zfs/zpl_file.c | 26 ++++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/module/os/linux/zfs/zpl_file.c b/module/os/linux/zfs/zpl_file.c
index 2bdb53579ae..30013c38d8e 100644
--- a/module/os/linux/zfs/zpl_file.c
+++ b/module/os/linux/zfs/zpl_file.c
@@ -710,6 +710,20 @@ zpl_putfolio(struct folio *pp, struct writeback_control *wbc, void *data)
 }
 #endif
 
+static inline int
+zpl_write_cache_pages(struct address_space *mapping,
+    struct writeback_control *wbc, void *data)
+{
+	int result;
+
+#ifdef HAVE_WRITEPAGE_T_FOLIO
+	result = write_cache_pages(mapping, wbc, zpl_putfolio, data);
+#else
+	result = write_cache_pages(mapping, wbc, zpl_putpage, data);
+#endif
+	return (result);
+}
+
 static int
 zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
@@ -732,11 +746,7 @@ zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 	 * and then we commit it all in one go.
 	 */
 	wbc->sync_mode = WB_SYNC_NONE;
-#ifdef HAVE_WRITEPAGE_T_FOLIO
-	result = write_cache_pages(mapping, wbc, zpl_putfolio, mapping);
-#else
-	result = write_cache_pages(mapping, wbc, zpl_putpage, mapping);
-#endif
+	result = zpl_write_cache_pages(mapping, wbc, mapping);
 	if (sync_mode != wbc->sync_mode) {
 		ZPL_ENTER(zfsvfs);
 		ZPL_VERIFY_ZP(zp);
@@ -752,11 +762,7 @@ zpl_writepages(struct address_space *mapping, struct writeback_control *wbc)
 		 * details). That being said, this is a no-op in most cases.
 		 */
 		wbc->sync_mode = sync_mode;
-#ifdef HAVE_WRITEPAGE_T_FOLIO
-		result = write_cache_pages(mapping, wbc, zpl_putfolio, mapping);
-#else
-		result = write_cache_pages(mapping, wbc, zpl_putpage, mapping);
-#endif
+		result = zpl_write_cache_pages(mapping, wbc, mapping);
 	}
 	return (result);
 }
